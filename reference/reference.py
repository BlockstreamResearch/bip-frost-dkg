# Reference implementation of BIP DKG. This file is automatically generated by
# reference_py_gen.sh.

from secp256k1 import n as GROUP_ORDER, Point, G, point_add, point_mul, schnorr_sign as sign, schnorr_verify as verify_sig, tagged_hash, bytes_from_point
from typing import Tuple, List, Optional, Callable, Any, Union

biptag = "BIP DKG: "

def tagged_hash_bip_dkg(tag: str, msg: bytes) -> bytes:
    return tagged_hash(biptag + tag, msg)

def kdf(seed, tag, extra_input):
    # TODO: consider different KDF
    return tagged_hash_bip_dkg(tag + "KDF ", seed + extra_input)


def point_add_multi(points: List[Optional[Point]]) -> Optional[Point]:
    acc = None
    for point in points:
        acc = point_add(acc, point)
    return acc

# A scalar is represented by an integer modulo GROUP_ORDER
Scalar = int

# A polynomial is represented by a list of coefficients
# f(x) = coeffs[0] + ... + coeff[n] * x^n
Polynomial = List[Scalar]

# Evaluates polynomial f at x
def polynomial_evaluate(f: Polynomial, x: Scalar) -> Scalar:
   value = 0
   # Reverse coefficients to compute evaluation via Horner's method
   for coeff in f[::-1]:
        value = (value * x) % GROUP_ORDER
        value = (value + coeff) % GROUP_ORDER
   return value

# Returns [f(1), ..., f(n)] for polynomial f with coefficients coeffs
def secret_share_shard(f: Polynomial, n: int) -> List[Scalar]:
    return [polynomial_evaluate(f, x_i) for x_i in range(1, n + 1)]

# A VSS Commitment is a list of points
VSSCommitment = List[Optional[Point]]

# Returns commitments to the coefficients of f
def vss_commit(f: Polynomial) -> VSSCommitment:
    vss_commitment = []
    for coeff in f:
        A_i = point_mul(G, coeff)
        vss_commitment.append(A_i)
    return vss_commitment

def vss_verify(signer_idx: int, share: Scalar, vss_commitment: VSSCommitment) -> bool:
     P = point_mul(G, share)
     Q = [point_mul(vss_commitment[j], pow(signer_idx + 1, j) % GROUP_ORDER) \
          for j in range(0, len(vss_commitment))]
     return P == point_add_multi(Q)

VSSCommitmentSum = Tuple[List[Optional[Point]], List[bytes]]

# Sum the commitments to the i-th coefficients from the given vss_commitments
# for i > 0. This procedure is introduced by Pedersen in section 5.1 of
# 'Non-Interactive and Information-Theoretic Secure Verifiable Secret Sharing'.
def vss_sum_commitments(vss_commitments: List[Tuple[VSSCommitment, bytes]], t: int) -> VSSCommitmentSum:
    n = len(vss_commitments)
    assert(all(len(vss_commitment[0]) == t for vss_commitment in vss_commitments))
    # The returned array consists of 2*n + t - 1 elements
    # [vss_commitments[0][0][0], ..., vss_commitments[n-1][0][0],
    #  sum_group(vss_commitments[i][1]), ..., sum_group(vss_commitments[i][t-1]),
    #  vss_commitments[0][1], ..., vss_commitments[n-1][1]]
    return ([vss_commitments[i][0][0] for i in range(n)] + \
           [point_add_multi([vss_commitments[i][0][j] for i in range(n)]) for j in range(1, t)],
           [vss_commitments[i][1] for i in range(n)])

# Outputs the shared public key and individual public keys of the participants
def derive_group_info(vss_commitment: VSSCommitment, n: int, t: int) -> Tuple[Optional[Point], List[Optional[Point]]]:
  pk = vss_commitment[0]
  participant_public_keys = []
  for signer_idx in range(0, n):
    pk_i = point_add_multi([point_mul(vss_commitment[j], pow(signer_idx + 1, j) % GROUP_ORDER) \
                            for j in range(0, len(vss_commitment))])
    participant_public_keys += [pk_i]
  return pk, participant_public_keys

SimplePedPopR1State = Tuple[int, int]
VSS_PoK_msg = (biptag + "VSS PoK").encode()

def simplpedpop_round1(seed: bytes, t: int, n: int) -> Tuple[SimplePedPopR1State, Tuple[VSSCommitment, bytes], List[Scalar]]:
    """
    Start SimplPedPop by generating messages to send to the other participants.

    :param bytes seed: FRESH, UNIFORMLY RANDOM 32-byte string
    :param int t: threshold
    :param int n: number of participants
    :return: a state, a VSS commitment and shares
    """
    coeffs = [kdf(seed, "coeffs", i) for i in range(t)]
    sig = sign(VSS_PoK_msg, coeffs[0], kdf(seed, "VSS PoK", ""))
    # FIXME make sig a separate thing
    my_vss_commitment = (vss_commit(coeffs), sig)
    my_generated_shares = secret_share_shard(coeffs, n)
    state = (t, n)
    return state, my_vss_commitment, my_generated_shares

class InvalidContributionError(Exception):
    def __init__(self, signer, error):
        self.signer = signer
        self.contrib = error

def simplpedpop_finalize(state: SimplePedPopR1State, my_idx: int,
                         vss_commitments_sum: VSSCommitmentSum, shares_sum: Scalar,
                         Eq: Callable[[Any],bool] , eta: Any = ()) \
                         -> Union[Tuple[Scalar, Optional[Point], List[Optional[Point]]], bool]:
    """
    Take the messages received from the participants and finalize the DKG

    :param int my_idx:
    :param List[bytes] vss_commitments_sum: output of running vss_sum_commitments() with vss_commitments from all participants (including this participant) (TODO: not a list of bytes)
    :param scalar shares_sum: summed shares from all participants (including this participant) for this participant mod group order
    :param eta: Optional argument for extra data that goes into `Eq`
    :return: a final share, the shared pubkey, the individual participants' pubkeys
    """
    t, n = state
    assert(len(vss_commitments_sum) == 2*n + t - 1)
    for i in range(n):
        P_i = vss_commitments_sum[0][i]
        if P_i is None:
            raise InvalidContributionError(i, "Participant sent invalid commitment")
        else:
            pk_i = bytes_from_point(P_i)
            if not verify_sig(VSS_PoK_msg, pk_i, vss_commitments_sum[1][i]):
                raise InvalidContributionError(i, "Participant sent invalid proof-of-knowledge")
    eta += (vss_commitments_sum)
    # Strip the signatures and sum the commitments to the constant coefficients
    vss_commitments_sum_coeffs = [point_add_multi([vss_commitments_sum[0][i] for i in range(n)])] + vss_commitments_sum[0][n:n+t-1]
    if not vss_verify(my_idx, shares_sum, vss_commitments_sum_coeffs):
        return False
    if not Eq(eta):
        return False
    shared_pubkey, signer_pubkeys = derive_group_info(vss_commitments_sum_coeffs, n, t)
    return shares_sum, shared_pubkey, signer_pubkeys
