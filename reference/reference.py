# Reference implementation of BIP DKG. This file is automatically generated by
# reference_py_gen.sh.

from secp256k1 import n as GROUP_ORDER, Point, G, point_add, point_mul, schnorr_sign as sign, schnorr_verify as verify_sig, tagged_hash, bytes_from_point, individual_pk, point_add_multi, scalar_add_multi
from typing import Tuple, List, Optional, Callable, Any, Union
from network import *
from util import *

biptag = "BIP DKG: "

def tagged_hash_bip_dkg(tag: str, msg: bytes) -> bytes:
    return tagged_hash(biptag + tag, msg)

def kdf(seed, tag, extra_input):
    # TODO: consider different KDF
    return tagged_hash_bip_dkg(tag + "KDF ", seed + extra_input)

# A scalar is represented by an integer modulo GROUP_ORDER
Scalar = int

# A polynomial is represented by a list of coefficients
# f(x) = coeffs[0] + ... + coeff[n] * x^n
Polynomial = List[Scalar]

# Evaluates polynomial f at x
def polynomial_evaluate(f: Polynomial, x: Scalar) -> Scalar:
   value = 0
   # Reverse coefficients to compute evaluation via Horner's method
   for coeff in f[::-1]:
        value = (value * x) % GROUP_ORDER
        value = (value + coeff) % GROUP_ORDER
   return value

# Returns [f(1), ..., f(n)] for polynomial f with coefficients coeffs
def secret_share_shard(f: Polynomial, n: int) -> List[Scalar]:
    return [polynomial_evaluate(f, x_i) for x_i in range(1, n + 1)]

# A VSS Commitment is a list of points
VSSCommitment = List[Optional[Point]]

VSSCommitmentSum = Tuple[List[Optional[Point]], List[bytes]]

# Returns commitments to the coefficients of f
def vss_commit(f: Polynomial) -> VSSCommitment:
    vss_commitment = []
    for coeff in f:
        A_i = point_mul(G, coeff)
        vss_commitment.append(A_i)
    return vss_commitment

def vss_verify(signer_idx: int, share: Scalar, vss_commitment: VSSCommitment) -> bool:
     P = point_mul(G, share)
     Q = [point_mul(vss_commitment[j], pow(signer_idx + 1, j) % GROUP_ORDER) \
          for j in range(0, len(vss_commitment))]
     return P == point_add_multi(Q)

# Sum the commitments to the i-th coefficients from the given vss_commitments
# for i > 0. This procedure is introduced by Pedersen in section 5.1 of
# 'Non-Interactive and Information-Theoretic Secure Verifiable Secret Sharing'.
def vss_sum_commitments(vss_commitments: List[Tuple[VSSCommitment, bytes]], t: int) -> VSSCommitmentSum:
    n = len(vss_commitments)
    assert(all(len(vss_commitment[0]) == t for vss_commitment in vss_commitments))
    # The returned array consists of 2*n + t - 1 elements
    # [vss_commitments[0][0][0], ..., vss_commitments[n-1][0][0],
    #  sum_group(vss_commitments[i][1]), ..., sum_group(vss_commitments[i][t-1]),
    #  vss_commitments[0][1], ..., vss_commitments[n-1][1]]
    return ([vss_commitments[i][0][0] for i in range(n)] + \
           [point_add_multi([vss_commitments[i][0][j] for i in range(n)]) for j in range(1, t)],
           [vss_commitments[i][1] for i in range(n)])

# Outputs the shared public key and individual public keys of the participants
def derive_group_info(vss_commitment: VSSCommitment, n: int, t: int) -> Tuple[Optional[Point], List[Optional[Point]]]:
  pk = vss_commitment[0]
  participant_public_keys = []
  for signer_idx in range(0, n):
    pk_i = point_add_multi([point_mul(vss_commitment[j], pow(signer_idx + 1, j) % GROUP_ORDER) \
                            for j in range(0, len(vss_commitment))])
    participant_public_keys += [pk_i]
  return pk, participant_public_keys

SimplePedPopR1State = Tuple[int, int]
VSS_PoK_msg = (biptag + "VSS PoK").encode()

def simplpedpop_round1(seed: bytes, t: int, n: int) -> Tuple[SimplePedPopR1State, Tuple[VSSCommitment, bytes], List[Scalar]]:
    """
    Start SimplPedPop by generating messages to send to the other participants.

    :param bytes seed: FRESH, UNIFORMLY RANDOM 32-byte string
    :param int t: threshold
    :param int n: number of participants
    :return: a state, a VSS commitment and shares
    """
    coeffs = [kdf(seed, "coeffs", i) for i in range(t)]
    sig = sign(VSS_PoK_msg, coeffs[0], kdf(seed, "VSS PoK", ""))
    # FIXME make sig a separate thing
    my_vss_commitment = (vss_commit(coeffs), sig)
    my_generated_shares = secret_share_shard(coeffs, n)
    state = (t, n)
    return state, my_vss_commitment, my_generated_shares

def simplpedpop_finalize(state: SimplePedPopR1State, my_idx: int,
                         vss_commitments_sum: VSSCommitmentSum, shares_sum: Scalar,
                         Eq: Callable[[Any],bool] , eta: Any = ()) \
                         -> Union[Tuple[Scalar, Optional[Point], List[Optional[Point]]], bool]:
    """
    Take the messages received from the participants and finalize the DKG

    :param int my_idx:
    :param List[bytes] vss_commitments_sum: output of running vss_sum_commitments() with vss_commitments from all participants (including this participant) (TODO: not a list of bytes)
    :param scalar shares_sum: summed shares from all participants (including this participant) for this participant mod group order
    :param eta: Optional argument for extra data that goes into `Eq`
    :return: a final share, the shared pubkey, the individual participants' pubkeys
    """
    t, n = state
    assert(len(vss_commitments_sum) == 2*n + t - 1)
    for i in range(n):
        P_i = vss_commitments_sum[0][i]
        if P_i is None:
            raise InvalidContributionError(i, "Participant sent invalid commitment")
        else:
            pk_i = bytes_from_point(P_i)
            if not verify_sig(VSS_PoK_msg, pk_i, vss_commitments_sum[1][i]):
                raise InvalidContributionError(i, "Participant sent invalid proof-of-knowledge")
    eta += (vss_commitments_sum)
    # Strip the signatures and sum the commitments to the constant coefficients
    vss_commitments_sum_coeffs = [point_add_multi([vss_commitments_sum[0][i] for i in range(n)])] + vss_commitments_sum[0][n:n+t-1]
    if not vss_verify(my_idx, shares_sum, vss_commitments_sum_coeffs):
        return False
    if not Eq(eta):
        return False
    shared_pubkey, signer_pubkeys = derive_group_info(vss_commitments_sum_coeffs, n, t)
    return shares_sum, shared_pubkey, signer_pubkeys

def ecdh(x, Y, context):
    return tagged_hash("ECDH", x*Y, context)

def encrypt(share, my_deckey, enckey, context):
    return (share + ecdh(my_deckey, enckey, context)) % GROUP_ORDER

EncPedPopR1State = Tuple[bytes, bytes]

def encpedpop_round1(seed: bytes) -> Tuple[EncPedPopR1State, bytes]:
    my_deckey = kdf(seed, "deckey", "")
    my_enckey = individual_pk(my_deckey)
    state1 = (my_deckey, my_enckey)
    return state1, my_enckey

EncPedPopR2State = Tuple[int, bytes, bytes, List[bytes], SimplePedPopR1State]

def encpedpop_round2(seed: bytes, state1: EncPedPopR1State, t: int, n: int, enckeys: List[bytes]) -> Tuple[EncPedPopR2State, Tuple[VSSCommitment, bytes], List[Scalar]]:
    assert(n == len(enckeys))
    if len(enckeys) != len(set(enckeys)):
        raise DuplicateEnckeysError

    my_deckey, my_enckey = state1
    # Protect against reuse of seed in case we previously exported shares
    # encrypted under wrong enckeys.
    assert(t < 2**(4*8))
    seed_ = tagged_hash_bip_dkg("EncPedPop seed", seed + t.to_bytes(4, byteorder="big") + b''.join(enckeys))
    simpl_state, vss_commitment, shares = simplpedpop_round1(seed_, t, n)
    enc_context = hash([t] + enckeys)
    enc_shares = [encrypt(shares[i], my_deckey, enckeys[i], enc_context) for i in range(len(enckeys))]
    state2 = (t, my_deckey, my_enckey, enckeys, simpl_state)
    return state2, vss_commitment, enc_shares

def encpedpop_finalize(state2: EncPedPopR2State, vss_commitments_sum: VSSCommitmentSum, enc_shares_sum: Scalar, Eq: Callable[[Any],bool], eta: Any = ()) -> Union[Tuple[Scalar, Optional[Point], List[Optional[Point]]], bool]:
    t, my_deckey, my_enckey, enckeys, simpl_state = state2
    n = len(enckeys)
    assert(len(vss_commitments_sum) == 2*n + t - 1)

    enc_context = hash([t] + enckeys)
    shares_sum = enc_shares_sum - scalar_add_multi([ecdh(my_deckey, enckeys[i], enc_context) for i in range(n)])
    try:
        my_idx = enckeys.index(my_enckey)
    except ValueError:
        raise BadCoordinatorError("Coordinator sent list of encryption keys that does not contain our key.")
    eta += (enckeys)
    return simplpedpop_finalize(simpl_state, my_idx, vss_commitments_sum, shares_sum, Eq, eta)
